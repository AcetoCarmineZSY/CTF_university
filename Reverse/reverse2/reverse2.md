# Write-up Reverse 2

Nous ouvrons le fichier `encoreunflag` avec IDA32 bits et trouvons la fonction `main`. Au niveau de `[esp + Ch][ebp - Ch]`, nous découvrons un list de chaînes s : `char *s`. Il y a deux fonctions, gagne et perdu:`type int gagne(void)`,`type int perdu(void)`. Dans la branche sous main, nous trouvons `“suntax：%s<password>\n"` et la fonction gagne. Puis, il y a des blocs de code assembleur répétitifs, "cmp" suivi de "jne" perdu (), c’est-a-dire `if(xxx) perdu()；`. Nous supposons que les conditions if représentent les conditions où le mot de passe ne passe pas et déduisons le mot de passe à partir de ces instructions. En examinant les instructions assembleur cmp...jz, la première condition est strlen (s) != 20, donc nous avons créé une liste de 20 dans le script py. La deuxième condition est *s != 67, ce qui signifie que s [0] = 67. La troisième condition est s [1] != 70, etc. Finalement, nous avons obtenu la chaîne complète s et la convertissons en lettres pour obtenir le Flag.

